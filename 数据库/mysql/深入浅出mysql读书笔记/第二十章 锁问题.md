# MySql架构

下面是mysql服务器的各组件之间的逻辑架构图

![1584275908940](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200316143018-573123.png)

- 连接层，最上层的服务并不是 `MYSQL`所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。
- 服务层，第二层架构是 `MYSQL`比较有意思的部分。大多数 `MYSQL`的核心服务功能都在这一层，包括査询解析、分析、优化、缓存以及所有的内置函数(例如日期、时间、数学和加密函数)，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
- 引擎层，负责`MYSQL`中数据的储存和提取，提供了各种数据储存方法（两种重要引擎：`InnoDB`  `MYISAM`），服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的査询过程透明。支持的引擎可以通过命令`show engines; ` 命令查看，我们也可以通过下面的命令查看默认的存储引擎。

```sql
mysql> show variables like '%storage_engine%';
```

> 这里要特别注意的就是服务层的优化器和引擎层，这是将我们后面讨论的重点！
>
> mysql执行前会进行查询缓存->解析->优化->执行
>
> `MYSQL`会解析查询，并创建内部数据结构(解析树)，然后对其进行各种优化，包括重写査询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示(`hint`)优化器，影响它的决策过程。我们可以请求优化器解释(`explain`)优化过程的各个因素，使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构査询，使应用尽可能高效运行。优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。例如，某些存储引擎的某种索引，可能对一些特定的查询有优化。例如对于 SELECT语句，在解析査询之前，服务器会先检査查询缓存(`Query Cache`)，如果能够在其中找到对应的査询，服务器就不必再执行査询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。



# 第20章 锁问题

## 20.1 MySQL 锁概述

当数据库中，数据作为许多用户共享的资源，如何保证数据的并发性访问的一致性呢？

锁一般是有储存引擎提供的，但是尽管存储引擎可以管理自己的锁，`MySQL`本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如 `ALTER TABLE`之类的语句使用表锁，而忽略存储引擎的锁机制（但是行锁只在储存引擎中实现）。比如，`MyISAM`和`MEMORY`存储引擎采用的是表级锁（`table-level locking`）；BDB存储引擎采用的是页面锁（`page-level locking`），但也支持表级锁；`InnoDB`存储引擎既支持行级锁（`row-level locking`），也支持表级锁，但默认情况下是采用行级锁。

加锁也需要消耗资源。锁的各种操作,包括获得锁、检査锁是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这种平衡当然也会影响到性能。

MySQL这3种锁的特性可大致归纳如下：

1. 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
2. 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
3. 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。



## 20.2 MyISAM 表锁

### 20.2.1 查询表级锁争用情况

可以通过检查`table_locks_waited`和`table_locks_immediate`状态变量来分析系统上的表锁争用情况：

```sql
mysql> show status like 'table%';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Table_locks_immediate | 2979  |
| Table_locks_waited    | 0     |
+-----------------------+-------+
2 rows in set (0.00 sec))

```

- `Table_locks_immediate`：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1；
- `Table_locks_waited` ：出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，毎等待一次锁值加1)，此值高则说明存在着较严重的表级锁争用情况;



### 20.2.2 MySQL 表级锁的锁模式

`MySQL` 的表级锁有两种模式：表共享读锁（`Table Read Lock`）和表独占写锁（`Table Write Lock`）。锁模式的兼容性如表 20-1 所示

![1585220213615](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200326185653-633032.png)

可见，对 `MyISAM` 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 `MyISAM` 表的写操作，则会阻塞其他用户对同一表的读和写操作；`MyISAM` 表的读操作与写操作之间，以及写操作之间是串行的！根据如表 20-2 所示的例子可以知道，当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。

**MyISAM 存储引擎的写阻塞读例子**

| 获得表 film_text 的 WRITE 锁定<br /><br />mysql> lock table film_text write;<br /><br />Query OK, 0 rows affected (0.00 sec)<br /> |      |
| ------------------------------------------------------------ | ---- |
|                                                              |      |
|                                                              |      |
|                                                              |      |







![1585220772469](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200326190614-63658.png)

![1585220786462](C:\Users\古春波\AppData\Roaming\Typora\typora-user-images\1585220786462.png)

### 20.2.3 如何加表锁

MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。在本书的示例中，显式加锁基本上都是为了方便而已，并非必须如此。给 MyISAM 表显示加锁，一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表 orders，其中记录有各订单的总金额 total，同时还有一个订单明细表 order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相符，可能就需要执行如下两条 SQL：

```sql
Select sum(total) from orders;
Select sum(subtotal) from order_detail;
```

这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail 表可能已经发生了改变。因此，正确的方法应该是：

```sql
Lock tables orders read local, order_detail read local;
Select sum(total) from orders;
Select sum(subtotal) from order_detail;
Unlock tables;

```

要特别说明以下两点内容。
上面的例子在 LOCK TABLES 时加了“local”选项，其作用就是在满足 MyISAM 表并发插入条件的情况下，允许其他用户在表尾并发插入记录，有关 MyISAM 表的并发插入问题，在后面的章节中还会进一步介绍。
在用 LOCK TABLES 给表显式加表锁时，必须同时取得所有涉及到表的锁，并且 MySQL 不支持锁升级。也就是说，在执行 LOCK TABLES 后，**只能访问显式加锁的这些表**，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁。这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。在如表 20-3 所示的例子中，一个 session 使用 LOCK TABLE 命令给表 film_text 加了读锁，这个 session 可以查询锁定表中的记录，但更新或**访问其他表**都会提示错误；同时，另外一个session 可以查询表中的记录，但更新就会出现锁等待。

**MyISAM 存储引擎的读阻塞写例子**

![1585224495525](C:\Users\古春波\AppData\Roaming\Typora\typora-user-images\1585224495525.png)

![1585224517834](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200326200839-881581.png)

![1585224578993](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200326202001-331359.png)

当使用 LOCK TABLES 时，不仅需要一次锁定用到的所有表，而且，同一个表在 SQL 语句中出现多少次，就要通过与 SQL 语句中相同的别名锁定多少次，否则也会出错！举例说明如下。

（1）对 actor 表获得读锁：

```sql
mysql> lock table actor read;
Query OK, 0 rows affected (0.00 sec)
```

（2）但是通过别名访问会提示错误：

```sql
mysql> select a.first_name,a.last_name,b.first_name,b.last_name from actor a,actor b where 
a.first_name = b.first_name and a.first_name = 'Lisa' and a.last_name = 'Tom' and a.last_name 
<> b.last_name;
ERROR 1100 (HY000): Table 'a' was not locked with LOCK TABLES
```

（3）需要对别名分别锁定：

```sql
mysql> lock table actor as a read,actor as b read;
Query OK, 0 rows affected (0.00 sec)
```

（4）按照别名的查询可以正确执行：

```sql
mysql> select a.first_name,a.last_name,b.first_name,b.last_name from actor a,actor b where 
a.first_name = b.first_name and a.first_name = 'Lisa' and a.last_name = 'Tom' and a.last_name 
<> b.last_name;
+------------+-----------+------------+-----------+
| first_name | last_name | first_name | last_name |
+------------+-----------+------------+-----------+
| Lisa       | Tom       | LISA       | MONROE    |
+------------+-----------+------------+-----------+
1 row in set (0.00 sec)
```

### 20.2.4 并发插入（Concurrent Inserts）

上文提到过 MyISAM 表的读和写是串行的，但这是就总体而言的。在一定条件下，MyISAM表也支持查询和插入操作的并发进行。MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。
 当concurrent_insert设置为0时，不允许并发插入。
 当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。
 当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。

在如表 20-4 所示的例子中，session_1 获得了一个表的 READ LOCAL 锁，该线程可以对表进行查询操作，但不能对表进行更新操作；其他的线程（session_2），虽然不能对表进行删除和更新操作，但却可以对该表进行并发插入操作，这里假设该表中间不存在空洞。

**MyISAM 存储引擎的读写（INSERT）并发例子**

![1585225566964](C:\Users\古春波\AppData\Roaming\Typora\typora-user-images\1585225566964.png)

![1585225553254](C:\Users\古春波\AppData\Roaming\Typora\typora-user-images\1585225553254.png)

可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入的锁争用。例如，将concurrent_insert系统变量设为2，总是允许并发插入；同时，通过定期在系统空闲时段执行OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录而产生的中间空洞。有关OPTIMIZE TABLE语句的详细介绍，可以参见第18章中“两个简单实用的优化方法”一节的内容。

### 20.2.5 MyISAM 的锁调度

前面讲过，MyISAM 存储引擎的读锁和写锁是互斥的，读写操作是串行的。那么，一个进程请求某个 MyISAM 表的读锁，同时另一个进程也请求同一表的写锁，MySQL 如何处理呢？答案是写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前！这是因为 MySQL 认为写请求一般比读请求要重要。这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节 MyISAM 的调度行为。

很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节 MyISAM 的调度行为。
通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。
通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。
通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。

虽然上面 3 种方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。上面已经讨论了写优先调度机制带来的问题和解决办法。这里还要强调一点：一些需要长时间运行的查询操作，也会使写进程“饿死”！因此，应用中应尽量避免出现长时间运行的查询操作，不要总想用一条SELECT语句来解决问题，因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。

## 20.3 InnoDB 锁问题

### 20.3.1 背景知识

innodb是事务型的，会自动提交事务

“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本上可分为以下两种。
 一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。
 另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或MCC），也经常称为多版本数库。

为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92 定义了 4 个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡“隔离”与“并发”的矛盾。表 20-5 很好地概括了这 4 个隔离级别的特性。

![1585229899930](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200327100351-357754.png)

最后要说明的是：各具体数据库并不一定完全实现了上述 4 个隔离级别，例如，Oracle 只提供 Read committed 和 Serializable 两个标准隔离级别，另外还提供自己定义的 Read only 隔离级别；SQL Server 除支持上述 ISO/ANSI SQL92 定义的 4 个隔离级别外，还支持一个叫做“快照”的隔离级别，但严格来说它是一个用 MVCC 实现的 Serializable 隔离级别。MySQL 支持全部 4 个隔离级别，但在具体实现时，有一些特点，比如在一些隔离级别下是采用 MVCC一致性读，但某些情况下又不是，这些内容在后面的章节中将会做进一步介绍。

### 20.3.2 获取 InnoDB 行锁争用情况

可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况

```sql
mysql> show status like 'innodb_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| InnoDB_row_lock_current_waits | 0     |
| InnoDB_row_lock_time          | 0     |
| InnoDB_row_lock_time_avg      | 0     |
| InnoDB_row_lock_time_max      | 0     |
| InnoDB_row_lock_waits         | 0     |
+-------------------------------+-------+
5 rows in set (0.01 sec)
```

如果发现锁争用比较严重，如 InnoDB_row_lock_waits 和 InnoDB_row_lock_time_avg 的值比较高，还可以通过设置 InnoDB Monitors 来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。
具体方法如下：

```sql
mysql> CREATE TABLE innodb_monitor(a INT) ENGINE=INNODB;
Query OK, 0 rows affected (0.14 sec)
```

然后就可以用下面的语句来进行查看：

```sql
mysql> Show innodb status\G;
*************************** 1. row ***************************
 
Type: InnoDB
 
Name: 
Status:
…
…
------------
TRANSACTIONS
------------
Trx id counter 0 117472192
Purge done for trx's n:o < 0 117472190 undo n:o < 0 0
History list length 17
Total number of lock structs in row lock hash table 0
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 0 117472185, not started, process no 11052, OS thread id 1158191456
MySQL thread id 200610, query id 291197 localhost root
---TRANSACTION 0 117472183, not started, process no 11052, OS thread id 1158723936
MySQL thread id 199285, query id 291199 localhost root
Show innodb status
…

```

监视器可以通过发出下列语句来停止查看：

```sql
mysql> DROP TABLE innodb_monitor;
Query OK, 0 rows affected (0.05 sec)
```

设置监视器后，在 SHOW INNODB STATUS 的显示内容中，会有详细的当前锁等待的信息，包括表名、锁类型、锁定记录的情况等，便于进行进一步的分析和问题的确定。打开监视器以后，默认情况下每 15 秒会向日志中记录监控的内容，如果长时间打开会导致.err 文件变得非常的巨大，所以用户在确认问题原因之后,记得删除监控表以关闭监视器，或者通过
使用“--console”选项来启动服务器以关闭写日志文件。

### 20.3.3 InnoDB 的行锁模式及加锁方法

InnoDB 实现了以下两种类型的行锁。
 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
 排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是**表锁**。
 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该**表**的 IS 锁。
 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该**表**的 IX 锁。
上述锁模式的兼容情况具体如表 20-6 所示。

![1585231675153](assets/1585231675153.png)

如果一个事务请求的锁模式与当前的锁兼容(注意锁冲突和兼容是两个事务间的事！)，InnoDB 就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。意向锁是 InnoDB 自动加的，不需用户干预。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB会自动给涉及数据集加排他锁（X)；**对于普通 SELECT 语句，InnoDB 不会加任何锁**；事务可以通过以下语句显示给记录集加共享锁或排他锁。
共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。

用 SELECT ... IN SHARE MODE 获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行 UPDATE 或者 DELETE 操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用 SELECT... FOR UPDATE 方式获得排他锁。

在如表 20-7 所示的例子中，使用了 SELECT ... IN SHARE MODE 加锁后再更新记录，看看会出现什么情况，其中 actor 表的 actor_id 字段为主键。建表：

```
creat table`actor`  (
  `actor_id` int(11) NOT NULL AUTO_INCREMENT,
  `first_name` varchar(255) DEFAULT NULL,
  `last_name` varchar(255)  DEFAULT NULL,
  PRIMARY KEY (`actor_id`) USING BTREE
) ENGINE = InnoDB
```

新建的连接都是默认的自动提交，因此每个session都手动设置为非自动提交

![1585232508576](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200326222148-420541.png)

![1585232531256](assets/1585232531256.png)

当使用SELECT...FOR UPDATE加锁后再更新记录，出现如表20-8所示的情况。

![1585232553213](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200326222247-174410.png)

![1585232568259](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200326222248-35829.png)

![1585232586316](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200326222306-975100.png)

### 20.3.4 InnoDB 行锁实现方式

InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！在实际应用中，要特别注意 InnoDB 行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。

（1）在不通过索引条件查询的时候，InnoDB 确实使用的是表锁，而不是行锁。在如表 20-9 所示的例子中，开始 tab_no_index 表没有索引：

```sql
mysql> create table tab_no_index(id int,name varchar(10)) engine=innodb;
Query OK, 0 rows affected (0.15 sec)
mysql> insert into tab_no_index values(1,'1'),(2,'2'),(3,'3'),(4,'4');
Query OK, 4 rows affected (0.00 sec)
Records: 4 Duplicates: 0 Warnings: 0
```

**InnoDB 存储引擎的表在不使用索引时使用表锁例子**

![1585275162624](assets/1585275162624.png)

在如表 20-9 所示的例子中，看起来 session_1 只给一行加了排他锁，但 session_2 在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB 只能使用表锁。当我们给其增加一个索引后，InnoDB 就只锁定了符合条件的行，如表 20-10 所示。

创建 tab_with_index 表，id 字段有普通索引：

```sql
mysql> create table tab_with_index(id int,name varchar(10)) engine=innodb;
Query OK, 0 rows affected (0.15 sec)
mysql> alter table tab_with_index add index id(id);
Query OK, 4 rows affected (0.24 sec)
Records: 4 Duplicates: 0 Warnings: 0
```

![1585275491744](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200327101813-102171.png)

（2）由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。在如表 20-11 所示的例子中，表 tab_with_index 的 id 字段有索引，name 字段没有索引：

![1585276095957](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200327102816-579705.png)

（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。在如表 20-12 所示的例子中，表 tab_with_index 的 id 字段有主键索引，name 字段有普通索引：

```sql
mysql> alter table tab_with_index add index name(name);
Query OK, 5 rows affected (0.23 sec)
Records: 5 Duplicates: 0 Warnings: 0
```

**InnoDB 存储引擎的表使用不同索引的阻塞例子**

![1585276311418](assets/1585276311418.png)

![1585276367519](assets/1585276367519.png)

（4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查 SQL 的执行计划，以确认是否真正使用了索引。关于 MySQL 在什么情况下不使用索引的详细讨论，参见本章“索引问题”一节的介绍。
在下面的例子中，检索值的数据类型与索引字段不同，虽然 MySQL 能够进行数据类型转换，但却不会使用索引，从而导致 InnoDB 使用表锁。通过用 explain 检查两条 SQL 的执行计划，我们可以清楚地看到了这一点。
例子中 tab_with_index 表的 name 字段有索引，但是 name 字段是 varchar 类型的，如果where 条件中不是和 varchar 类型进行比较，则会对 name 进行类型转换，而执行的全表扫描。

```sql
mysql> alter table tab_no_index add index name(name);
Query OK, 4 rows affected (8.06 sec)
Records: 4 Duplicates: 0 Warnings: 0
mysql> explain select * from tab_with_index where name = 1 \G
*************************** 1. row *************************** 
id: 1 
select_type: SIMPLE
table: tab_with_index 
type: ALL
possible_keys: name 
key: NULL 
key_len: NULL 
ref: NULL 
rows: 4
Extra: Using where
1 row in set (0.00 sec)
mysql> explain select * from tab_with_index where name = '1' \G
*************************** 1. row *************************** 
id: 1 
select_type: SIMPLE 
table: tab_with_index 
type: ref
possible_keys: name 
key: name 
key_len: 23 
ref: const 
rows: 1
Extra: Using where
1 row in set (0.00 sec)

```

### 20.3.5 间隙锁（Next-Key 锁）

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key 锁）。举例来说，假如 emp 表中只有 101 条记录，其 empid的值分别是 1,2,...,100,101，下面的 

```sql
SQL：Select * from emp where empid > 100 for update;
```

是一个范围条件的检索，InnoDB 不仅会对符合条件的 empid 值为 101 的记录加锁，也会对empid 大于 101（这些记录并不存在）的“间隙”加锁。InnoDB 使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了 empid 大于 100 的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对锁机制的影响，以及不同隔离级别下 InnoDB 使用间隙锁的情况，在后续的章节中会做进一步介绍。

很显然，在使用范围条件检索并锁定记录时，InnoDB 这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

还要特别说明的是，InnoDB 除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB 也会使用间隙锁！
在如表 20-13 所示的例子中，假如 emp 表中只有 101 条记录，其 empid 的值分别是1,2,......,100,101。

![1585277494296](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200327105141-955588.png)

![1585277535041](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200327105215-757178.png)



### 20.3.9 关于死锁

上文讲过，MyISAM 表锁是 deadlock free 的，这是因为 MyISAM 总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。如表 20-17 所示的就是一个发生死锁的例子。

![1585290764287](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200327143315-447502.png)

![1585290799338](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200327143320-554528.png)

在上面的例子中，两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。
发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁，这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决。需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。

通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小，以及访问数据库的 SQL 语句，绝大部分死锁都可以避免。下面就通过实例来介绍几种避免死锁的常用方法。

（1）在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。在下面的例子中，由于两个 session 访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可以避免。

![1585291241272](assets/1585291241272.png)

![1585291281455](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200327144121-436453.png)



### 查看innodb行锁

```
mysql> show status like 'innodb_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| Innodb_row_lock_current_waits | 0     |
| Innodb_row_lock_time          | 0     |
| Innodb_row_lock_time_avg      | 0     |
| Innodb_row_lock_time_max      | 0     |
| Innodb_row_lock_waits         | 0     |
+-------------------------------+-------+
5 rows in set (0.01 sec)
```

![1585492479850](assets/1585492479850.png)

# 测试

建表

```sql
CREATE TABLE `mylock`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20)  DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM  ROW_FORMAT = Dynamic;

INSERT INTO `mylock` VALUES (1, 'a');
INSERT INTO `mylock` VALUES (2, 'b');
INSERT INTO `mylock` VALUES (3, 'c');
INSERT INTO `mylock` VALUES (4, 'd');
INSERT INTO `mylock` VALUES (5, 'e');
```





读锁

![1585488254788](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200329212421-694560.png)

![1585488309494](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200329212510-223129.png)

![1585488314959](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200329212518-288972.png)



写锁



![1585488799037](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200329213321-481904.png)

![1585488819226](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200329213339-925995.png)

行锁

![1585490980894](assets/1585490980894.png)



不恰当使用索引导致索引行锁升级为表锁

varchar  不用 ' '  导致系统自动转换类型, 行锁变表锁

![1585491675035](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200329222224-11877.png)







# 事务

事务就是一组原子性的*SQL*査询,或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组査询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。

## 事务的ACID特性

银行应用是解释事务必要性的一个经典例子。假设一个银行的数据库有两张表:支票( *checking*)表和储蓄( *savings*)表。现在要从用户Jane的支票账户转移200美元到她的储蓄账户，那么需要至少三个步骤

![1584276392783](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200402132020-48258.png)

可以用 *START TRANSACTION*语句开始一个事务，然后要么使用*COMMIT*提交事务将修改的数据持久保留，要么使用 *ROLLBACK*撤销所有的修改。事务SQL的样本如下

![1585817639262](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200402165400-652970.png)

单纯的事务概念并不是故事的全部。试想一下，如果执行到第四条语句时服务器崩溃了，会发生什么?天知道，用户可能会损失200美元。再假如，在执行到第三条语句和第四条语句之间时，另外一个进程要删除支票账户的所有余额，那么结果可能就是银行在不知道这个逻辑的情况下白白给了Jane 200美元。

系统通过严格的ACID测试，否则空谈事务的概念是不够的。ACID表示原子性(atomicity)、一致性(consistency)、隔离性(isolation)和持久性(durability)。一个运行良好的事务处理系统,必须具备这些标准特征。

- 原子性(atomicity)，一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败回滚,对于一个事务来说,不可能只执行其中的一部分操作,这就是事务的原子性

- 一致性(consistency)，数据库总是从一个一致性的状态转换到另外一个一致性的状态。在前面的例子中,如果一致性确保了,即使在执行第三、四条语句之间时系统崩溃,支票账户中也不会损失200美元,因为事务最终没有提交,所以事务中所做的修改也不会保存到数据库中。

- 隔离性(isolation)，通常来说,一个事务所做的修改在最终提交以前，对其他事务是不可见的。在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外一个账户汇总程序开始运行，则其看到的支票账户的余额并没有被减去200美元。后面我们讨论隔离级别(`Isolation level`)的时侯，会发现为什么我们要说“通常来说”是不可见的。

- 持久性(durability)，一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。

  

事务的ACID特性可以确保银行不会弄丢你的钱。而在应用逻辑中，要实现这一点非常难，甚至可以说是不可能完成的任务。一个兼容ACID的数据库系统，需要做很多复杂但可能用户并没有觉察到的工作，需要增大许多的系统开销，才能确保ACID的实现。可以根据是否需要事务，来决定使用什么储存引擎。

> **一个事务不是总能够实现ACID特性！**



数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，锁的应用最终导致不同事务的隔离级别。

[事务和锁机制是什么关系？ 开启事务就自动加锁了吗？](https://zhidao.baidu.com/question/751754554948922124.html)

1、事务与锁是不同的。事务具有ACID（原子性、一致性、隔离性和持久性），锁是用于解决隔离性的一种机制。

2、事务的隔离级别通过锁的机制来实现。另外锁有不同的粒度，同时事务也是有不同的隔离级别的。

3、开启事务就自动加锁。https://www.cnblogs.com/leijiangtao/p/11911644.html





## 隔离级别

在SQL标准中定义了四种隔离级别,每一种级別都规定了个事务中所做的修改,哪些在事务内和事务间是可见的,哪些是不可见的。较低级别的隔离通常可以执行更高的并发,系统的开销也更低。

### READ UNCOMMITTED(读未提交)

在 *READ UNCOMMITTED*级别，事务中的修改,即使没有提交,对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读(*Dirty Read*)。这个级别会导致很多问题，从性能上来说，*READ UNCOMMITTED*不会比其他的级别好太多,但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。

### READ COMMITTED(读已提交)

大多数数据库系统的默认隔离级别都是 *READ COMMITTED*(但 *MYSQL*不是)。*READ COMMITTED*满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”其它事务已经提交所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。但也就是这个可以“看见”其它事务已经提交的更改，可能会造成以下问题：如果两次执行同样的査询，可能会得到不一样的结果。【一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了! 这种现象就叫做“不可重复读”。一句话：事务A读取到了事务B已经提交的修改数据，不符合隔离性】一个事务A在读c表的一条数据某个时间后,事务A再次读取以前c表的该条数据,却发现其读出的数据已经发生了改变、或某些记录已经被删除了!这种现象就叫做“不可重复读”。一句话:事务A读取到了另一个事务B对c表的已经提交的修改数据,不符合隔离性。[视频讲解](https://www.bilibili.com/video/BV1RE41187Yo?p=58)

### REPEATABLE READ(可重复读)

该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读(*Phantom Read*)的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录另外一个事务又在该范围内插入了新的记录，当之前的事务再次以相同条件读取该范围的记录时，会产生幻行(*Phantom Row*)。 INNODB存储引擎通过多版本并发控制(*MVCC, Multiversion Concurrency Control*)解决了幻读的问题。稍后会做进一步的讨论，可重复读是 *MYSQL*的默认事务隔离级别

### SERIIALIZABLE(可串行化)

*SERIALIZABLE*是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说, *SERIALIZABLE*会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

> 【**不可重复读和幻读区别：**不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了】



## MySql中的事务

*MYSQL*提供了两种事务型的存储引擎: *Innodb*和 NDB Cluster，*MYSQL*服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。

### 自动提交

自动提交(*AUTO COMMIT*)，*MYSQL*默认采用自动提交(*AUTO COMMIT*)模式。也就是说，如果不是显式地开始一个事务，则每个査询都被当作一个事务执行提交操作。在当前连接中，可以通过设置*AUTO COMMIT*变量来启用或者禁用自动提交模式：

![1584282322099](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200315222522-316144.png)

1或者*ON*表示启用，0或者*OFF*表示禁用。当 *AUTOCOMMIT=0*时，所有的査询都是在一个事务中，直到显式地执行 *COMMIT* 提交或者 *ROLLBACK*回滚，该事务结束，同时又开始了，另一个新事务。修改 *AUTO COMMIT* 对非事务型的表，比如 *MYISAM*或者内存表，不会有任何影响。对这类表来说，没有 *COMMIT* 或者 *ROLLBACK*的概念，也可以说是相当于一直处于 *AUTO COMMIT*启用的模式。

另外还有一些命令，在执行之前会强制执行 *COMMIT*提交当前的活动事务。典型的例子，在数据定义语言(*DDL*)中，如果是会导致大量数据改变的操作，比如 *ALTER TABLE*就是如此。另外还有 *LOCK TABLES*等其他语句也会导致同样的结果。如果有需要，请检査对应版本的官方文档来确认所有可能导致自动提交的语句列表。

### 在事务中混合使用存储引擎

MYSQL服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。如果在事务中混合使用了事务型和非事务型的表(例如 INNODB和 MYISAM表)，在正常提交的情况下不会有什么问题。但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。在非事务型的表上执行事务相关操作的时候，MYSQL通常不会发出提醒，也不会报错。有时候只有回滚的时候才会发出一个警告：“某些非事务型的表上的变更不能被回滚”。但大多数情况下，对非事务型表的操作都不会有提示。

### **隐式和显式锁定**

INNODB采用的是两阶段锁定协议(*two-phase locking protocol*)。在事务执行过程中，随时都可以执行锁定，锁只有在执行 *COMMIT*或者 *ROLLBACK*的时侯才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，*INNODB*会根据隔离级别在需要的时侯自动加锁。另外，*INNODB*也支持通过特定的语句进行显式锁定，但是应该尽量避免使用。

![1584786332227](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200321182533-678769.png)

MYSQL也支持LOCK TABLES和*UNLOCK TABLES*语句，这是在服务器层实现的，和存储引擎无关。它们有自己的用途，但并不能替代事务处理。如果应用需要用到事务，还是应该选择事务型存储引擎。经常可以发现，应用已经将表从 *MYISAM*转换到 *INNODB*，但还是显式地使用*L0CK TABLES*语句。这不但没有必要，还会严重影响性能，实际上 *INNODB*的行级锁工作得更好。



## 多版本并发控制

MYSQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑,它们一般都同时实现了多版本并发控制(MVCC)。不仅是 MYSQL,包Oracle Postgresql等其他数据库系统也都实现了MVCC,但各自的实现机制不尽相同,因为MVCC没有一个统一的实现标准。可以认为MVCC是行级锁的一个变种,但是它在很多情况下避免了加锁操作,因此开销更低。虽然实现机制有所不同,但大都实现了非阻塞的读操作,写操作也只锁定必要的行。

MVCC的实现,是通过保存数据在某个时间点的快照来实现的。也就是说,不管需要执行多长时间,每个事务看到的数据都是一致的。根据事务开始的时间不同,每个事务对同一张表，同一时刻看到的数据可能是不一样的。如果之前没有这方面的概念,这句话听起来就有点迷惑。熟悉了以后会发现,这句话其实还是很容易理解的。

前面说到不同存储引擎的MVCC实现是不同的,典型的有乐观( optimistic)并发控制和悲观( pessimistic)并发控制。下面我们通过 INNODB的简化版行为来说明MVCC是如何工作的。

INNODB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列,个保存了行的创建时间,一个保存行的过期时间(或删除时间)。当然存储的并不是实际的时间值，而是系统版本号( system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和査询到的每行记录的版本号进行比较。下面看一下在 REPEATABLE READ隔离级别下,MVCC具体是如何操作的。

![1584789003439](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200321191005-857409.png)

保存这两个额外系统版本号,使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单,性能很好,并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间,需要做更多的行检査工作,以及一些额外的维护工作。MVCC只在 REPEATABLE READ和 READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容,因为 READ UNCOMMITTED总是读取最新的数据行,而不是符合当前事务版本的数据行。而 SERIALIZABLE则会对所有读取的行都加锁。







# 1. 索引

索引是储存引擎用来快速找到记录的一种数据结构，**注意：索引是一种数据结构**

要理解 MYSQL中索引是如何工作的，我们可以通过跟书的“索引”类比来理解，如果想在一本书中找到某个特定主题，一般会先看书的“索引”,找到对应的页码。在MYSQL中，储存引擎用类似的方法使用索引，首先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

假如要进行下面的查询`SELECT first_name FROM sakila.actor WHERE actor_id = 5`。如果在 `actor_id`列上建有索引，则 MYSQL将使用该索引找到`actor_id`为5的行，具体过程是这样的： MYSQL先在索引上按值进行查找对应的索引记录，然后通过该索引记录找到数据行并返回所有包含该值的数据行。

索引有很多种类型，可以为不同的场景提供更好的性能。在 MYSQL中，索引是在存储引擎层而不是服务器层实现的。所以,并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引,其底层的实现也可能不同。

