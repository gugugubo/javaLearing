

# MySql分层

![1584275908940](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200316143018-573123.png)

- 连接层，最上层的服务并不是 MYSQL所独有的,大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。
- 服务层，第二层架构是 MYSQL比较有意思的部分。大多数 MYSQL的核心服务功能都在这一层,包括査询解析、分析、优化、缓存以及所有的内置函数(例如,日期、时间、数学和加密函数),所有跨存储引擎的功能都在这一层实现:存储过程、触发器、视图等。
- 引擎层，负责mysql中数据的储存和提取，提供了各种数据储存方法（两种重要引擎：InnoDB  MyISAM），服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异,使得这些差异对上层的査询过程透明。支持的引擎可以通过命令`show engines; ` 命令查看，我们也可以通过下面的命令查看默认的存储引擎。


```sql
mysql> show variables like '%storage_engine%';
```

# 并发控制

**读写锁**

解决这类经典问题的方法就是并发控制,其实非常简单。在处理并发读或者写时,可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁( shared lock)和排他锁( exclusive lock),也叫读锁( read lock)和写锁( writelock)。这里先不讨论锁的具体实现,描述一下锁的概念如下:读锁是共享的,或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源,而互不干扰。写锁则是排他的也就是说一个写锁会阻塞其他的写锁和读锁,这是出于安全策略的考虑,只有这样,才能确保在给定的时间里,只有一个用户能执行写入,并防止其他用户读取正在写入的同资源。

**锁的粒度**

- 表锁是 MYSQL中最基本的锁策略,并且是开销最小的策略。它会锁定整张表。一个用户在对表进行写操作(插入、删除、更新等)前,需要先获得写锁,这会阻塞其他用户对该表的所有读写操作。只有没有写锁时,其他读取的用户才能获得读锁,读锁之间是不相互阻塞的。尽管存储引擎可以管理自己的锁, MYSQL本身还是会使用各种有效的表锁来实现不同的目的。例如,服务器会为诸如 ALTER TABLE之类的语句使用表锁,而忽略存储引擎的锁机制。
- 行级锁可以最大程度地支持并发处理(同时也带来了最大的锁开销)。行级锁可以最大程度地支持并发处理(同时也带来了最大的锁开销)。众所周知,在INNODB和 Xtradb,以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现,而 MYSQL服务器层没有实现。服务器层完全不了解存储引擎中的锁实现。


# 事务

事务就是一组原子性的SQL査询,或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组査询的全部语句,那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行,那么所有的语句都不会执行。也就是说,事务内的语句,要么全部执行成功,要么全部执行失败。

## 事务的ACID特性

银行应用是解释事务必要性的一个经典例子。假设一个银行的数据库有两张表:支票( checking)表和储蓄( savings)表。现在要从用户Jane的支票账户转移200美元到她的储蓄账户,那么需要至少三个步骤

![1584276392783](assets/1584276392783.png)

单纯的事务概念并不是故事的全部。试想一下,如果执行到第四条语句时服务器崩溃了,会发生什么?天知道,用户可能会损失200美元。再假如,在执行到第三条语句和第四条语句之间时,另外一个进程要删除支票账户的所有余额,那么结果可能就是银行在不知道这个逻辑的情况下白白给了Jane200美元。

除非系统通过严格的ACID测试,否则空谈事务的概念是不够的。ACID表示原子性( atomicity)、一致性( consistency)、隔离性( isolation)和持久性( durability)。一个运行良好的事务处理系统,必须具备这些标准特征。

- 原子性( atomicity)，一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败回滚,对于一个事务来说,不可能只执行其中的一部分操作,这就是事务的原子性

- 一致性( consistency)，数据库总是从一个一致性的状态转换到另外一个一致性的状态。在前面的例子中,一致性确保了,即使在执行第三、四条语句之间时系统崩溃,支票账户中也不会损失200美元,因为事务最终没有提交,所以事务中所做的修改也不会保存到数据库中。

- 隔离性( isolation)，通常来说,一个事务所做的修改在最终提交以前,对其他事务是不可见的。在前面的例子中,当执行完第三条语句、第四条语句还未开始时,此时有另外一个账户汇总程序开始运行,则其看到的支票账户的余额并没有被减去200美元。后面我们讨论隔离级别( Isolation level)的时侯,会发现为什么我们要说“通常来说”是不可见的。

- 持久性( durability)，一旦事务提交,则其所做的修改就会永久保存到数据库中。此时即使系统崩溃,修改的数据也不会丢失。持久性是个有点模糊的概念,因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障,而有些则未必。而且不可能有能做到100%的持久性保证的策略(如果数据库本身就能做到真正的持久性,那么备份又怎么能增加持久性呢?)。


事务的ACID特性可以确保银行不会弄丢你的钱。而在应用逻辑中,要实现这一点非常难,甚至可以说是不可能完成的任务。一个兼容ACID的数据库系统,需要做很多复杂但可能用户并没有觉察到的工作,才能确保ACID的实现。也就是说，**一个事务不是总能够实现ACID特性！**



数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，锁的应用最终导致不同事务的隔离级别。

[事务和锁机制是什么关系？ 开启事务就自动加锁了吗？](https://zhidao.baidu.com/question/751754554948922124.html)

1、事务与锁是不同的。事务具有ACID（原子性、一致性、隔离性和持久性），锁是用于解决隔离性的一种机制。

2、事务的隔离级别通过锁的机制来实现。另外锁有不同的粒度，同时事务也是有不同的隔离级别的。

3、开启事务就自动加锁。https://www.cnblogs.com/leijiangtao/p/11911644.html





## 隔离级别

在SQL标准中定义了四种隔离级别,每一种级別都规定了个事务中所做的修改,哪些在事务内和事务间是可见的,哪些是不可见的。较低级别的隔离通常可以执行更高的并发,系统的开销也更低。

### READ UNCOMMITTED(未提交读)

在 READ UNCOMMITTED级别,事务中的修改,即使没有提交,对其他事务也都是可见的。事务可以读取未提交的数据,这也被称为脏读( Dirty Read)。这个级别会导致很多问题,从性能上来说, READ UNCOMMITTED不会比其他的级别好太多,但却缺乏其他级别的很多好处,除非真的有非常必要的理由,在实际应用中一般很少使用。

### READ COMMITTED(提交读)

大多数数据库系统的默认隔离级别都是 READ COMMITTED(但 MYSQL不是)。READCOMMITTED满足前面提到的隔离性的简单定义:一个事务开始时,只能“看见”已经提交的事务所做的修改。换句话说,一个事务从开始直到提交之前,所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读( nonrepeatableread),因为两次执行同样的査询,可能会得到不一样的结果

### REPEATABLE READ(可重复读)

REPEATABLE READ解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上,可重复读隔离级别还是无法解决另外一个幻读( Phantom Read)的问题。所谓幻读,指的是当某个事务在读取某个范围内的记录时,另外一个事务又在该范围内插入了新的记录,当之前的事务再次读取该范围的记录另外一个事务又在该范围内插入了新的记录,当之前的事务再次以相同条件读取该范围的记录时,会产生幻行(Phantom Row)。 INNODB和 Xtradb存储引擎通过多版本并发控制(MVCC, Multiversion Concurrency Control)解决了幻读的问题。稍后会做进一步的讨论，可重复读是 MYSQL的默认事务隔离级别

### SERIIALIZABLE(可串行化)

SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行,避免了前面说的幻读的问题。简单来说, SERIALIZABLE会在读取的每一行数据上都加锁,所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别,只有在非常需要确保数据的一致性而且可以接受没有并发的情况下,才考虑采用该级别。



## MySql中的事务

MYSQL提供了两种事务型的存储引擎: Innodb和 NDB Cluster，MYSQL服务器层不管理事务,事务是由下层的存储引擎实现的。所以在同一个事务中,使用多种存储引擎是不可靠的。

### 自动提交

自动提交(AUTO COMMIT),MYSQL默认采用自动提交(AUTO COMMIT)模式。也就是说,如果不是显式地开始一个事务,则每个査询都被当作一个事务执行提交操作。在当前连接中,可以通过设置AUTO COMMIT变量来启用或者禁用自动提交模式：

![1584282322099](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200315222522-316144.png)

1或者ON表示启用,0或者OFF表示禁用。当 AUTOCOMMIT=0时,所有的査询都是在一个事务中,直到显式地执行 COMMIT提交或者 ROLLBACK回滚,该事务结束,同时又开始了，另一个新事务。修改 AUTO COMMIT 对非事务型的表,比如 MYISAM或者内存表,不会有任何影响。对这类表来说,没有 COMMIT 或者 ROLLBACK的概念,也可以说是相当于一直处于 AUTOCOMMIT启用的模式。

### **隐式和显式锁定**

INNODB采用的是两阶段锁定协议(two-phase locking protocol)。在事务执行过程中,随时都可以执行锁定,锁只有在执行 COMMIT或者 ROLLBACK的时侯才会释放,并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定, INNODB会根据隔离级别在需要的时侯自动加锁。另外, INNODB也支持通过特定的语句进行显式锁定，但是应该尽量避免使用

![1584786332227](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200321182533-678769.png)

MYSQL也支持 LOCK TABLES和 UNLOCK TABLES语句,这是在服务器层实现的,和存储引擎无关。它们有自己的用途,但并不能替代事务处理。如果应用需要用到事务,还是应该选择事务型存储引擎。经常可以发现,应用已经将表从 MYISAM转换到 INNODB,但还是显式地使用L0CK TABLES语句。这不但没有必要,还会严重影响性能,实际上 INNODB的行级锁工作得更好



## 多版本并发控制

MYSQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑,它们一般都同时实现了多版本并发控制(MVCC)。不仅是 MYSQL,包Oracle Postgresql等其他数据库系统也都实现了MVCC,但各自的实现机制不尽相同,因为MVCC没有一个统一的实现标准。可以认为MVCC是行级锁的一个变种,但是它在很多情况下避免了加锁操作,因此开销更低。虽然实现机制有所不同,但大都实现了非阻塞的读操作,写操作也只锁定必要的行。

MVCC的实现,是通过保存数据在某个时间点的快照来实现的。也就是说,不管需要执行多长时间,每个事务看到的数据都是一致的。根据事务开始的时间不同,每个事务对同一张表,同一时刻看到的数据可能是不一样的。如果之前没有这方面的概念,这句话听起来就有点迷惑。熟悉了以后会发现,这句话其实还是很容易理解的。

前面说到不同存储引擎的MVCC实现是不同的,典型的有乐观( optimistic)并发控制和悲观( pessimistic)并发控制。下面我们通过 INNODB的简化版行为来说明MVCC是如何工作的。

INNODB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的。这两个列,个保存了行的创建时间,一个保存行的过期时间(或删除时间)。当然存储的并不是实际的时间值,而是系统版本号( system version number)。每开始一个新的事务,系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号,用来和査询到的每行记录的版本号进行比较。下面看一下在 REPEATABLE READ隔离级别下,MVCC具体是如何操作的。

![1584789003439](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200321191005-857409.png)

保存这两个额外系统版本号,使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单,性能很好,并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间,需要做更多的行检査工作,以及一些额外的维护工作。MVCC只在 REPEATABLE READ和 READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容,因为 READ UNCOMMITTED总是读取最新的数据行,而不是符合当前事务版本的数据行。而 SERIALIZABLE则会对所有读取的行都加锁。







# 索引

要理解 MYSQL中索引是如何工作的,最简单的方法就是去看看一本书的“索引”部分如果想在一本书中找到某个特定主题,一般会先看书的“索引”,找到对应的页码。在MYSQL中，储存引擎用类似的方法使用索引，首先在索引中找到对应值，然后根据匹配的索引找到对应的数据行，加入要进行下面的查询`SELECT first_name FROM sakila.actor WHERE actor_id = 5`如果在 actor_id列上建有索引,则 MYSQL将使用该索引找到 actor_id为5的行,也就是说, MYSQL先在索引上按值进行查找,然后返回所有包含该值的数据行。

索引有很多种类型,可以为不同的场景提供更好的性能。在 MYSQL中,索引是在存储引擎层而不是服务器层实现的。所以,并没有统一的索引标准:不同存储引擎的索引的工作方式并不一样,也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引,其底层的实现也可能不同。

## 索引的类型

### B-Tree索引

当人们谈论索引的时候,如果没有特别指明类型,那多半说的是B-Tree索引,它使用B-Tree数据结构来存储数据。大多数 MYSQL引擎都支持这种索引。实际上很多存储引擊使用的是B+Tree的数据结构,即每一个叶子节点都包含指向下一个叶子节点的指针,从而方便叶子节点的范围遍历。我们使用术语“B-Tree”,是因为 MYSQL在 CREATE TABLE和其他语句中也使用该关键字。这里也说明，即使不同的储存引擎都是用B-Tree结构，但是不同的储存引擎都有不同的使用方式，具体实现方式不同。

B-Tree通常意味着所有的值都是按顺序存储的,并且每一个叶子页到根的距离相同。下图展示了B-Tree(实际上是B+树)索引的抽象表示,大致反映了 INNODB索引是如何工作的。 MYISAM使用的结构有所不同,但基本思想是类似的。

![1584369932532](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200316224532-23890.png)



B-Tree索引能够加快访问数据的速度，因为储存引擎不在需要进行全表扫描获取需要的数据，取而代之的是从索引的根节点进行搜索（上图未画出根节点），根节点的槽中存放了指向子节点的指针，储存引擎根据这些指针向下层查找，通过比较节点页的值和要查找的值可以找到合适的值进入下一层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值,要么该记录不存在。叶子节点比较特别,它们的指针指向的是被索引的数据,而不是其他的节点页(不同引擎的“指针”类型不同)。上图仅绘制了一个节点和其对应的叶子节点,其实在根节点和叶子节点之间可能有很多层节点页。树的深度和表的大小直接相关。以上就是索引的查找过程了，终于破解了我一直以来的疑惑了！

可以使用B-Tree索引的查询类型：B-Tree索引适用于**全键值、键值范围或键前缀査找**，其中键前缀査找只适用于根据最左前缀的査找。前面所述的索引对如下类型的查询有效，

- 全值匹配，全值匹配指的是和索引中的所有列进行匹配,例如前面提到的索引可用于査找姓名为 Cuba Allen、出生于1960-01-01的人。
- 匹配最左前缀，前面提到的索引可用于査找所有姓为 Allen的人,即只使用索引的第一列

- 匹配列前缀，也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于査找所有以J开头的姓的人。这里也只使用了索引的第一列

- 匹配范围值，例如前面提到的索引可用于查找姓在 Allen和 Barrymore之间的人。这里也只使用了素引的第一列

- 精确匹配某一列并范国匹配另外一列，前面提到的索引也可用于査找所有姓为AIln,并且名字是字母K开头(比如KimKarl等)的人。即第一列 Last name全匹配,第二列 first name范围匹配。

- 只访问索引的查询B-Tree通常可以支持“只访问索引的查询”,即査询只需要访问索引,而无须访问数据行。后面我们将单独讨论这种“覆盖索引”的优化

#### 使用B-Tree索引的一些限制



### 哈希索引

哈希索引( hash index)基于哈希表实现,只有精确匹配索引**所有列**的査询才有效。对于每一行数据,存储引擎都会对**所有的素引列**计算一个哈希码( hash code),哈希码是个较小的值,并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中,同时在哈希表中保存指向毎个数据行的指针.

在 MYSQL中,只有 Memory引擎显式支持哈希索引。这也是 Memory引擎表的默认索引类型, Memory引擎同时也支持B-Tree索引。值得一提的是, Memory引擎是支持非唯一哈希索引的,这在数据库世界里面是比较与众不同的。如果多个列的哈希值相同,索引会以链表的方式存放多个记录指针到同一个哈希条目中。

- 假设有下表：
  - ![1584371991363](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200316232006-190790.png)
- 表中有如下数据
  - ![1584372023012](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200316232026-113667.png)
- 假设使用假想的哈希函数f()，它返回下面的值
  - ![1584372073036](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200316233350-419262.png)
- 那么哈希索引的数据结构如下
  - ![1584372091259](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200316232131-460003.png)
- 注意每个槽的编号是顺序的，但是数据行不是,试试如下查询
  - ![1584372215852](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200316232337-604372.png)
- MYSQL先计算' Peter'的哈希值,并使用该值寻找对应的记录指针。因为f(' Peter')=8784,所以 MYSQL在索引中査找8784,可以找到指向第3行的指针,最后一步是比较第三行的值是否为' Peter',以确保就是要査找的行（因为考虑了哈希冲突的情况）。

#### Hash索引的一些限制



### 全文索引

全文索引是一种特殊的索引类型，它查找的是文本中的关键字，而不是直接比较索引中的值。全文搜索和其他几类索引的匹配方式完全不一样。它有许多需要注意的细节,如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情,而不是简单的WERE条件匹配。但是当前最新版本中（5.0）只有 MyISAM 存储引擎支持 FULLTEXT 索引，并且只限于 CHAR、VARCHAR 和 TEXT列。索引总是对整个列进行的，不支持局部（前缀）索引。

在相同的列上同时创建全文素引和基于值的B-Tree索引不会有冲突,全文索引适用于MATCH AGAINST操作,而不是普通的WHERE条件操作。



### 索引的好处

最常见的B-Tree素引,按照顺序存储数据,所以 MYSQL可以用来做 ORDER BY和 GROUP BY操作。因为数据是有序的,所以**B-Tree也就会将相关的列值都存储在一起**。最后,因为索引中存储了实际的列值,所以某些査询只使用索引就能够完成全部査询。

总结下来索引有如下三个优点

1. 索引大大减少了服务器需要扫描的数据量。
2. 索引可以帮助服务器避免排序和临时表。
3. 索引可以将随机I/O变为顺序I/O(https://www.cnblogs.com/myseries/p/12448042.html)

## 高性能的索引策略

### 独立的列

我们通常会看到一些查询不当地使用索引,或者使得 MYSQL无法使用已有的索引。如果查询中的列不是独立的,则 MYSQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分,也不能是函数的参数。例如,下面这个查询无法使用  actor_ id列的索引:mysql> `SELECT actor_id FROM sakila_actor WHERE actor_id+ 1= 5;`凭肉眼很容易看出 WHERE中的表达式其实等价于 actor id=4,但是 MYSQL无法自动解析这个方程式。这完全是用户行为。我们应该养成简化 WHERE条件的习惯,始终将索引列单独放在比较符号的一侧。下面是另一个常见的错误:mysql > `SELECT . . WHERE TO_DAYS ( CURRENT_DATE ) -TO_DAYS ( date_co1 ) < = 10`

### 前缀索引和索引的选择性

有时候需要索引很长的字符列,这会让索引变得大且慢。通常可以索引开始的部分字符,这样可以大大节约索引空间,从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指,不重复的索引值(也称为基数,cardinality)和数据表的记录总数(#T)的比值,范围从l/#T到1之间。索引的选择性越高则查询效率越高,因为选择性高的索引可以让 MYSQL在查找时过滤掉更多的行。唯一索引的选择性是1,这是最好的索引选择性,性能也是最好的。

一般情况下某个列前缀的选择性也是足够高的,足以满足査询性能。对于BLOB、TEXT或者很长的 VARCHAR类型的列,必须使用前缀索引,因为 MYSQL不允许索引这些列的完整长度。诀窍在于要选择足够长的前缀以保证较高的选择性,同时又不能太长(以便节约空间)。前缀应该足够长,以使得前缀索引的选择性接近于索引整个列。换句话说,前缀的“基数”应该接近于完整列的“基数”。

找到了合适的前缀长度,下面演示一下如何创建前缀索引，创建前缀长度为7的前缀索引:`mysql > ALTER TABLE sakila city _ demo ADD KEY ( city ( 7 ) ) ;`

#### 前缀索引的一些限制

前缀索引是一种能使索引更小、更快的有效办法,但另一方面也有其缺点: **MYSQL无法使用前缀索引做ORDER BY和 GROUP BY,?????**也无法使用前缀索引做覆盖扫描。



### 聚簇索引

聚簇索引并不是一种单独的索引类型,而是一种数据存储方式。具体的细节依赖于其实现方式,但 Innodb的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引时,它的数据行实际上存放在索引的叶子页( leaf page)中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方,所以一个表只能有一个聚簇索引(不过,覆盖索引可以模拟多个聚簇索引的情况,本章后面将详细介绍)。因为是存储引擎负责实现索引,因此不是所有的存储引擎都支持聚簇索引。本节我们主要关注 Innodb,但是这里讨论的原理对于任何支持聚簇索引的存储引擎都是适用的。下图展示了聚簇索引中的记录是如何存放的。注意到,叶子页包含了行的全部数据但是节点页只包含了索引列。在这个案例中,索引列包含的是整数值（到现在为止的索引列都只能使用主键列作为索引列，如果没有定义主键, INNODB会选择一个唯一的非空素引代替。如果没有这样的索引INNODB会隐式定义一个主键来作为聚簇素引）。

![1584438813313](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200321101845-310660.png)



#### 聚簇索引的一些限制

- 聚簇数据最大限度地提高了IO密集型应用的性能,但如果数据全部都放在内存中则访问的顺序就没那么重要了,聚簇索引也就没什么优势了。

- 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 Innode表中速度最快的方式。

- 更新聚簇索引列的代价很高,因为会强制 Innodb将每个被更新的行移动到新的位置（是因为数据行和相邻的键值紧凑地存储在一起？）

- 基于聚簇索引的表在插入新行,或者主键被更新导致需要移动行的时候,可能面临“页分裂( page split)”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时,存储引擎会将该页分裂成两个页面来容纳该行,这就是一次页分裂操作页分裂会导致表占用更多的磁盘空间。

- 聚簇索引可能导致全表扫描变慢,尤其是行比较稀疏,或者由于页分裂导致数据存储不连续的时候。
- 二级索引(非聚簇索引)可能比想象的要更大,因为在二级索引的叶子节点包含了引用行的主键列。
- 二级索引访问需要两次索引査找,而不是一次。最后一点可能让人有些疑惑,为什么二级索引需要两次索引査找?答案在于二级索引中保存的“行指针”的实质。要记住,二级索引叶子节点保存的不是指向行的物理位置的指针,而是行的主键值这意味着通过二级索引査找行,存储引擎需要找到二级索引的叶子节点获得对应的主键值,然后根据这个值去聚簇索引中査找到对应的行。这里做了重复的工作:两次B-Tree査找而不是一次。



#### InnoDB和MyISAM 数据分布

NNODB和 MYISAM的数据分布对比

聚簇索引和非聚簇索引的数据分布有区别,以及对应的主键索引和二级索引的数据分布也有区别,通常会让人感到困扰和意外。来看看 INNODB和 MYISAM是如何存储下面这个表的:

![1584458735329](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200317232536-201215.png)

假设该表的主键取值为1~10000,按照随机顺序插入并使用 OPTIMIZE TABLE命令做了优化。换句话说,数据在磁盘上的存储方式已经最优,但行的顺序是随机的。列coL2的值是从1~100之间随机赋值,所以有很多重复的值MYISAM的数据分布。 MYISAM的数据分布非常简单,所以先介绍它。 MYISAM按照数据插入的顺序存储在磁盘上,如图所示。

![1584458865866](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200317232804-303792.png)

在行的旁边显示了行号,从0开始递增。因为行是定长的,所以 MYISAM可以从表的开头跳过所需的字节找到需要的行( MYISAM并不总是使用上图中的“行号”,而是根据定长还是变长的行使用不同策略)这种分布方式很容易创建索引。

下面显示的一系列图，素引中的每个叶子节点包含“行号”。下图显示了表的主键col1。

![1584459027558](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200318142512-671026.png)

那col2列上的索引又会如何呢?有什么特殊的吗?回答是否定的:它和其他索引没有什么区别。

![1584459095787](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200317233136-467054.png)



**INNODB的数据分布**。因为 INNODB支持聚簇索引,所以使用非常不同的方式存储同样的数据。 INNODB以如下图所示的方式存储数据。

![1584459240111](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200317233400-674194.png)

第一眼看上去,感觉该图和前面的图没有什么不同,但再仔细看细节,会注意到该图显示了整个表,而不是只有索引。因为在 INNODB中,聚簇索引“就是”表,所以不像 MYISAM那样需要独立的行存储。聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列(在这个例子中是coL2)。如果主键是一个列前缀索引, INNODB也会包含完整的主键列和剩下的其他列。

还有一点和 MYISAM的不同是, INNODB的二级索引和聚簇索引很不相同。 INNODB级索引的叶子节点中存储的不是“行指针”,而是主键值,并以此作为指向行的“指针”。这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。使用主键值当作指针会让二级索引占用更多的空间,换来的好处是, INNODB在移动行时无须更新二级素引中的这个"指针"

下图显示了示例表的coL2索引。每一个叶子节点都包含了索引列(这里是coL2),紧接着是主键值(col1)

![1584459535271](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200317233857-804162.png)

下图是描述 INNODB和 MYISAM如何存放表的抽象图。从图中可以很容易看出INNODB和 MYISAM保存数据和素引的区别。

![1584459627383](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200318142514-483109.png)



#### 在 Innodb表中按主键顺序插入行

如果正在使用 Innodb表并且没有什么数据需要聚集,那么可以定义一个代理键( surrogate key)作为主键,这种主键的数据应该和应用无关,最简单的方法是使用AUT0 INCREMENT自增列。这样可以保证数据行是按顺序写入,对于根据主键做关联操作的性能也会更好。最好避免随机的(不连续且值的分布范围非常大)聚簇索引,特别是对于I/O密集型的应用。例如,从性能的角度考虑,使用UUID来作为聚簇索引则会很糟糕:它使得聚簇索引的插入变得完全随机,这是最坏的情况,使得数据没有任何聚集特性。为了演示这一点,我们做如下两个基准测试。第一个使用整数ID插入 userinfo表

![1584519297545](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200318161459-498470.png)

第二个例子是 userinfo uuid表。除了主键改为UUID,其余和前面的 userinfo表完全相同。

![1584519313147](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200318161615-291841.png)

我们测试了这两个表的设计。首先,我们在一个有足够内存容纳索引的服务器上向这两个表各插入100万条记录。然后向这两个表继续插入300万条记录,使索引的大小超过服务器的内存容量。下表对测试结果做了比较。

![1584519374887](assets/1584519374887.png)

注意到向UUID主键插入行不仅花费的时间更长,而且素引占用的空间也更大。这一方面是由于主键字段更长;另一方面毫无疑问是由于页分裂和碎片导致的。为了明白为什么会这样,来看看往第一个表中插入数据时,索引发生了什么变化。下图显示了插满一个页面后继续插入相邻的下一个页面的场景。

![1584519398896](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200318161644-412057.png)

如上图所示,因为主键的值是顺序的,所以 INNODB把毎一条记录都存储在上一条记录的后面。当达到页的最大填充因子时( INNODB默认的最大填充因子是页大小的15/16,留出部分空间用于以后修改),下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载,主键页就会近似于被顺序的记录填满,这也正是所期望的结果(然而,二级索引页可能是不ー样的)。对比一下向第二个使用了UUID聚簇素引的表插入数据,看看有什么不同,下图显示了结果。

![1584519555882](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200318161917-750136.png)

因为新行的主键值不一定比之前插入的大,所以 INNODB无法简单地总是把新行插人到索引的最后,而是需要为新的行寻找合适的位置一一通常是已有数据的中间位置一一并且分配空间。这会增加很多的额外工作,并导致数据分布不够优化。下面是总结的一些缺点

- 写入的目标页可能已经刷到磁盘上并从缓存中移除,或者是还没有被加载到缓存中,INNODB在插入之前不得不先找到并从磁盘读取目标顶到内存中。这将导致大量的随机I/O。

- 因为写入是乱序的, INNODB不得不频繁地做顶分裂操作,以便为新的行分配空间。页分裂会导致移动大量数据,一次插入最少需要修改三个页而不是一个页

- 由于频繁的页分裂,页会变得稀疏并被不规则地填充,所以最终数据会有碎片。在把这些随机值载入到聚簇素引以后,也许需要做一次 OPTIMIZE TABLE来重建表并优化页的填充。


从这个案例可以看出,使用 INNODB时应该尽可能地按主键顺序插入数据,并且尽可能地使用单调增加的聚簇键的值来插入新行。



### 覆盖索引

通常大家都会根据查询的 WHERE条件来创建合适的索引,不过这只是索引优化的一个方面。设计优秀的索引应该考虑到整个查询,而不单单是 WHERE条件部分。索引确实是种査找数据的高效方式,但是 MYSQL也可以使用索引来直接获取列的数据,这样就不再需要读取数据行。如果索引的叶子节点中已经包含要查询的数据,那么还有什么必要再回表查询呢?如果一个索引包含(或者说覆盖)所有需要查询的字段的值,我们就称之为“覆盖索引“

覆盖索引是非常有用的工具,能够极大地提髙性能。考虑一下如果査询只需要扫描索引而无须回表,会带来多少好处

- 索引条目通常远小于数据行大小,所以如果只需要读取索引,那 MYSQL就会极大地减少数据访问量。这对缓存的负载非常重要,因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于I/O密集型的应用也有帮助,因为索引比数据更小,更容易全部放入内存中(这对于 MYISAM尤其正确,因为 MYISAM能压缩索引以变得更小)。
- 一些存储引擎如 MYISAM在内存中只缓存索引,数据则依赖于操作系统来缓存,因此要访问数据需要一次系统调用。这可能会导致严重的性能问题,尤其是那些系统调用占了数据访问中的最大开销的场景。

- 由于 INNODB的聚簇索引,覆盖索引对 INNODB表特别有用。 INNODB的二级索引在叶子节点中保存了行的主键值,所以如果二级主键能够覆盖査询,则可以避免对主键索引的二次査询

在所有这些场景中,在素引中满足査询的成本一般比査询行要小得多。不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值,而哈希索引、空间索引和全文索引等都不存储索引列的值,所以 MYSQL只能使用B-Tree素引做覆盖索引。另外,不同的存储引檠实现覆盖索引的方式也不同,而且不是所有的引擎都支持覆盖索引(在写作本书时, Memory存储引擎就不支持覆盖索引）

当发起一个被索引覆盖的查询(也叫做索引覆盖查询)时,在 EXPLAIN的 Extra列可以看到" Using index”的信息。例如,表 sakila. inventory有一个多列索引( store_id,film_id)。 MYSQL如果只需访问这两列,就可以使用这个索引做覆盖素引,如下所示:

![1584524435038](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200318174035-888245.png)

但是在大多数存储引擎中,覆盖索引只能覆盖那些只访问索引中部分列的査询。



### 使用索引扫描来做排序

MYSQL有两种方式可以生成有序的结果:通过排序操作;或者按素引顺序扫描,如果EXPLAIN出来的type列的值为“index”,则说明 MYSQL使用了素引扫描来做排序(不要和 Extra列的“ Using index”搞混淆了)。

扫描索引本身是很快的,因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖査询所需的全部列,那就不得不每扫描一条索引记录就都回表査询一次对应的行。这基本上都是随机I/O,因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢,尤其是在IO密集型的工作负载时。

MYSQL可以使用同一个素引既满足排序,又用于查找行。因此,如果可能,设计索引时应该尽可能地同时满足这两种任务,这样是最好的。只有当索引的列顺序和 ORDER BY子句的顺序完全一致,并且所有列的排序方向(倒序或正序)都一样时, MYSQLオ能够使用索引来对结果做排序，如果查询需要关联多张表,则只有当ORDER BY子句引用的字段全部为第一个表时,才能使用素引做排序。ORDER BY子句和査找型査询的限制是一样的:需要满足索引的最左前缀的要求;否则MYSQL都需要执行排序操作,而无法利用素引排序。有一种情况下 RDER BY子句可以不满足索引的最左前缀的要求,就是前导列为常量的时候。如果 WHERE子句或者J0IN子句中对这些列指定了常量,就可以“弥补”索引的不足。

有一种情况下 ORDER BY子句可以不满足索引的最左前缀的要求,就是前导列为常量的时候。如果 AHERE子句或者0IN子句中对这些列指定了常量,就可以“弥补”索引的不足。

![1584526439854](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200318181444-222494.png)

MYSQL可以使用 rental_date索引为下面的査询做排序,从 EXPLAIN中可以看到没有出现在磁盘中读取文件进行排序操作。

即使 ORDER BY子句不满足索引的最左前缀的要求,也可以用于査询排序,这是因为索引的第一列被指定为一个常数。还有更多可以使用索引做排序的査询示例。下面这个査询可以利用索引排序,是因为查询为素引的第一列提供了常量条件,而使用第二列进行排序,将两列组合在一起,就形成了索引的最左前缀

![1584526580994](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200318181621-253840.png)



![1584526835683](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200318182144-412659.png)



### 压缩(前缀压缩)索引

MYISAM使用前缀压缩来减少索引的大小,从而让更多的索引可以放入内存中,这在某些情况下能极大地提高性能。默认只压缩字符串,但通过参数设置也可以对整数做压缩。

MYISAM压缩每个索引块的方法是,先完全保存索引块中的第一个值,然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分,把这部分存储起来即可。例如,索引块中的第一个值是“ perform",第二个值是 performance",那么第个值的前缀压缩后存储的是类似“7,ance”这样的形式。 MYISAN对行指针也采用类似的前缀压缩方式。

压缩块使用更少的空间,代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值,所以 MYISAM査找时无法在索引块使用二分査找而只能从头开始扫描。正序的扫描速度还不错,但是如果是倒序扫描一一例如 ORDER BY DESC-一就不是很好了。所有在块中査找某一行的操作平均都需要扫描半个索引块







## 索引的分类

### 单值索引

- **单值索引：单列，一个表可以有多个单值索引**
  - **唯一索引：唯一索引,与普通索引类似,但是不同的是唯一索引要求列所有的值是唯一的,这一点和主键索引一样.但是他允许有空值**
  - **主键索引,不允许有空值,(在B+TREE中的InnoDB引擎中,主键索引起到了至关重要的地位)，主键索引建立的规则是 int优于varchar,一般在建表如果设置了主键就会自动创建,最好是与表的其他字段不相关的列或者是业务不相关的列.**
  - **普通索引,这个是最基本的索引**

```sql
#1.添加UNIQUE(唯一索引)
alter table 'table_name' add unique('column');

#2.添加PRIMARY KEY(主键索引)
alter table 'table_name' add primary key('column');

#3.添加普通索引
alter table 'table_name' add index index_name('column');
```



### 复合索引

- **复合索引：多个列构成的索引，相当于二级目录，一个表中含有多个单列索引不代表是组合索引,通俗一点讲 组合索引是:包含多个字段但是只有一个索引名称**

```sql
#5.添加多列索引
alter table 'table_name' add index index_name('column1','column2','column3');
```



### 全文索引

文本字段上(text)如果建立的是普通索引,那么只有对文本的字段内容前面的字符进行索引,其字符大小根据索引建立索引时申明的大小来规定.

如果文本中出现多个一样的字符,而且需要查找的话,那么其条件只能是 where column lick '%xxxx%' 这样做会让索引失效这个时候全文索引就起到了作用了

```sql
#4.添加全文索引
alter table 'table_name' add fulltext(column1, column2);
```

有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。

```sql
ELECT * FROM tablename
WHERE MATCH(column1, column2) AGAINST(‘xxx′, ‘sss′, ‘ddd′)
```

这条命令将把column1和column2字段里有xxx、sss和ddd的数据记录全部查询出来。





## 需要注意的地方

- **在表与表的而连接条件上加上索引,可以加快连接查询的速度**

- 在经常需要排序(order by),分组(group by)和的distinct 列上加索引 可以加快排序查询的时间,  (单独order by 用不了索引，索引考虑加where 或加limit)

- like语句的 如果你对nickname字段建立了一个索引.当查询的时候的语句是 nickname lick '%ABC%' 那么这个索引讲不会起到作用.而nickname lick 'ABC%' 那么将可以用到索引

- **使用短索引,如果你的一个字段是Char(32)或者int(32),在创建索引的时候指定前缀长度 比如前10个字符 (前提是多数值是唯一的..)那么短索引可以提高查询速度,并且可以减少磁盘的空间,也可以减少I/0操作.  什么是短索引？？**

- **很少数据的列也不应该建立索引,比如 一个性别字段 0或者1,在查询中,结果集的数据占了表中数据行的比例比较大,mysql需要扫描的行数很多,增加索引,并不能提高效率， 什么是结果集和数据行？？**

  

# 储存引擎



可以使用 SHOW TABLE STATUS命令显示表的相关信息。例如使用命令`show TABLE STATUS like 'award' \G;`

```properties
           Name: award   
           # 表名
         Engine: InnoDB
        Version: 10
     Row_format: Dynamic
     # 行的格式，对于行的格式。对于 MYISAM表,可选的值为 Dynamic、 Fixed或者 Compressed。Dynamiced的行长度是可变的,一般包含可变长度的字段,如 VARCHAR或BL0B。 Fixed的行长度则是固定的,只包含固定长度的列,如CHAR和 INTEGER。 Compressed的行则只在压缩表中存在
           Rows: 4
           #表中的行数。对于 MYISAM和其他一些存储引擎,该值是精确的,但对于 INNODB该值是估计值。
 Avg_row_length: 4096
 #平均每行包含的字节数
    Data_length: 16384
   # 表数据的大小，单位为字节
Max_data_length: 0
 # 表数据的最大长度，该值和储存引擎有关系
   Index_length: 0
   # 索引的大小
      Data_free: 0
      #对于 MYISAM表,表示已分配但目前没有使用的空间。这部分空间包括了之前删除的行,以及后续可以被 INSERT利用到的空间。
 Auto_increment: NULL
 # 下一个Auto_increment的值
    Create_time: 2020-03-15 09:02:24
    Update_time: NULL
    # 表数据最后的修改时间
     Check_time: NULL
     # 使用 CKECK TABLE命令或者 myisamchk工具最后一次检査表的时间。
      Collation: utf8_general_ci
      # 表默认的字符集和字符列排序规则
       Checksum: NULL
       # 如果开启，则保存的是整个表的实时校验和
 Create_options: 
 # 创建表时的其它选项
        Comment: 获奖信息表

```



## InnoDB储存引擎

INNODB的数据存储在表空间( tablespace)中,表空间是由 INNODB管理的一个黑盒子,由一系列的数据文件组成。在 MYSQL4.4以后的版本中, INNODB可以将每个表的数据和素引存放在单独的文件中。 INNODB也可以使用裸设备作为表空间的存储介质,但现代的文件系统使得裸设备不再是必要的选择。

INNODB采用MVCC来支持高并发,并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ(可重复读),并且通过间隙锁(next-key locking)策路防止幻读的出现。间隙锁使得 INNODB不仅仅锁定査询涉及的行,还会对索引中的间隙进行锁定,以防止幻影行的插入

INNODB表是基于聚簇索引建立的,我们会在后面的章节详细讨论聚簇索引。 INNODB的素引结构和 MYSQL的其他存储引擎有很大的不同,聚簇索引对主键査询有很高的性能不过它的二级索引( secondary index,非主键素引)中必须包含主键列,所以如果主键列很大的话,其他的所有索引都会很大。因此,若表上的索引较多的话,主键应当尽可能的小。 INNODB的存储格式是平台独立的,也就是说可以将数据和索引文件从 Intel平台复制到 Powerpc或者 Sun SPARC平台



## MyISAM存储引擎

MYISAM会将表存储在两个文件中:数据文件和索引文件,分别以,MYD和.MYI为扩展名。 MYISAM表可以包含动态或者静态(长度固定)行。 MYSQL会根据表的定义来决定采用何种行格式。 MYISAM表可以存储的行记录数,一般受限于可用的磁盘空间,或者操作系统中单个文件的最大尺寸。

在mysql5.1之前，都是使用MyISAM作为默认的储存引擎，MyISAM提供了大量的特性，包括全文索引，压缩，空间函数等，但是它不支持事务和行锁，且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。对于只读的数据或者表比较小、可以忍受修复( repair)操作 ,则依然可以继续使用 MYISAM(但请不要默认使用 MYISAM,而是应当默认使用 Innode)。

修复对于 MYISAM表, MYSQL可以手工或者自动执行检査和修复操作,但这里说的修复和事务恢复以及崩溃恢复是不同的概念。执行表的修复可能导致一些数据丢失,而且修复操作是非常慢的。可以通过 CHECK TABLE mytable检査表的错误,如果有错误可以通过执行 REPAIR TABLE mytable进行修复。另外,如果 MYSQL服务器已经关闭,也可以通过 myisamchk命令行工具进行检査和修复操作。

**索引特性，对于 MYISAM表,即使是BL0B和TET等长字段,也可以基于其前500个字符创建索引。 MYISAN也支持全文索引,这是一种基于分词创建的索引,可以支持复杂的査询。**

**延迟更新索引键( Delayed Key Write)创建 MYISAM表的时候,如果指定了 DELAY KEY WRITE选项,在每次修改执行完成时,不会立刻将修改的索引数据写入磁盘,而是会写到内存中的键缓冲区(in-memoryey buffer),只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种方式可以极大地提升写入性能,但是在数据库或者主机崩溃时会造成索引损坏,需要执行修复操作。延迟更新索引键的特性,可以在全局设置,也可以为单表设置。**





# sql性能问题

分析sql执行计划：explain ，可以模拟sql优化器执行sql，从而让开发人员知道自己编写的sql具体的执行！

- id:查询编号

- select type：表示 SELECT 的类型

- table：输出结果集的表。

- type：表示表的连接类型

- possible_keyss：表示查询时，可能使用的索引。

- key：表示实际使用的索引。

- key_len:由数据库编码决定

- ref:表之间的引用

- rows：扫描行的数量。

- Extra：执行情况的说明和描述。



### id

id值相同，从上往下顺序执行（就是行数少的表优先查询）

```sql
EXPLAIN SELECT tc.tcdesc FROM teacherCard tc,teacher t , course c WHERE c.tid = t.tid and t.tcid = tc.tcid and c.cname = 'sql' # 查询教授sql课程老师的描述信息
```

![1584242420543](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200315112021-914607.png)



如果id值不同，执行的查询顺序是，id值越大的越优先查询（其实就是在嵌套子查询时，先查内层，再查外层）

```sql
EXPLAIN SELECT tc.tcdesc FROM teacherCard tc WHERE tc.tcid = (
		SELECT t.tcid FROM teacher t WHERE t.tid = (SELECT c.tid FROM course c WHERE c.cname = 'sql')
)# 查询教授sql课程老师的描述信息
```

结果![1584242176103](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200315111617-198074.png)



id值有相同有不同，则id大的先查询，然后相同的就是上往下查询，使用子查询和多表查询

```sql
EXPLAIN SELECT tc.tcdesc , t.tname  FROM teacherCard tc, teacher t WHERE t.tcid = tc.tcid 
and t.tid = (SELECT c.tid FROM course c WHERE c.cname = 'sql'); # 查询教授sql课程老师的描述信息
```

![1584242734816](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200315112535-253662.png)

### select_type

1. PRIMAEY：最外层的 select 查询

2. SUBQUERY：子查询中的第一个 select 查询,不依赖于外部查询的结果集

3. DEPENDENT SUBQUERY：子查询中的第一个 select 查询,依赖于外部 查询的结果集 

4. SIMPLE：简单查询即不包含子查询和union的查询

5. DERIVED：衍生查询，在查询的时候用到了临时表的在from子查询中只有一张表，那么该表就是衍生查询，但是我的mysql5.7只是显示简单查询，那为何不是PRIMAEY查询？？
   EXPLAIN SELECT cr.cname FROM (SELECT * FROM course WHERE tid in (1,2 ) ) cr;

6. 

7. 在from子查询中，如果有table1 union table2 ，那么table1 就是DERIVED ，table2 就是UNION

   ```sql
   EXPLAIN SELECT cr.cname  FROM  (SELECT *  FROM course  WHERE tid =1 UNION SELECT * FROM course where tid = 2 )cr;
   ```

   

| select_type查询类型 |                             说明                             |
| ------------------- | :----------------------------------------------------------: |
| PRIMARY             |                     最外层的 select 查询                     |
| SIMPLE              |           简单的 select 查询,不使用 union 及子查询           |
| SUBQUERY            |    子查询中的第一个 select 查询,不依赖于外部查询的结果集     |
| DEPENDENT SUBQUERY  |     子查询中的第一个 select 查询,依赖于外部 查询的结果集     |
| DERIVED             | 用于 from 子句里有子查询的情况。 MySQL 会递归执行这些子查询, 把结果放在临时表里。 |
| UNION               | UNION 中的第二个或随后的 select 查询,不 依赖于外部查询的结果集 |
| DEPENDENT UNION     | UNION 中的第二个或随后的 select 查询,依 赖于外部查询的结果集 |
| UNCACHEABLE UNION   |  UNION 中的第二个或随后的 select 查询,属 于不可缓存的子查询  |

2.常见的selectType举例

- SIMPLE：简单的 select 查询,不使用 union 及子查询

- PRIMARY：也就是最后执行的语句

- SUBQUERY：在select或者where中包含了子查询

- DERIVED：临时表会增加MYSQL负担，但是有时候不得不用，类比：Java中两个变量交换数值

  - ```sql
    EXPLAIN SELECT cr.cname  FROM  (SELECT *  FROM course  WHERE tid =1 UNION SELECT * FROM course where tid = 2 )cr;
    ```

  - 在from子查询中，如果有table1 union table2 ，那么table1 就是DERIVED ，table2 就是UNION

  - ![查询结果](https://gitee.com/gu_chun_bo/java-construct/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/assets/1584244142524.png)

- UNION：两个表的查询结果合并

- ```ruby
  mysql> EXPLAIN SELECT t1.id from t1 UNION SELECT t2.id from t2;
  +----+--------------+------------+------+---------------+------+---------+------+------+-------+
  | id | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra |
  +----+--------------+------------+------+---------------+------+---------+------+------+-------+
  |  1 | PRIMARY      | t1         | ALL  | NULL          | NULL | NULL    | NULL |    3 |       |
  |  2 | UNION        | t2         | ALL  | NULL          | NULL | NULL    | NULL |    3 |       |
  | NULL | UNION RESULT | <union1,2> | ALL  | NULL          | NULL | NULL    | NULL | NULL |       |
  +----+--------------+------------+------+---------------+------+---------+------+------+-------+
  ```

- UNION RESULT：从合并的结果中进行再次查询，案例上面一张图就是



### type

表示表的连接类型，[实例演示](https://www.cnblogs.com/heat-man/p/4945708.html)

- system 只有一条数据的系统表，或者衍生表（临时表）只有一条数据的主查询

- const 单表中最多有一个匹配行，例如 primary key 或者 unique index

  - 设置表`tid`字段为主键，然后执行

    ```sql
    EXPLAIN SELECT * FROM test01 WHERE tid=1
    ```

  - ![1584258005082](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200315154010-360960.png)

- eq_ref：对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接中使用primary key或者unique index

- ref：与eq_ref类似，区别在于不是使用primary key 或者 unique index，而是使用普通的索引

- ref_or_null：与 ref 类似，区别在于条件中包含对 NULL 的查询

- index_merge：索引合并优化

- unique_subquery：in的后面是一个查询主键字段的子查询

- index_subquery：与 unique_subquery 类似，区别在于 in 的后面是查询非唯一索引字段的子查询

- range：单表中的范围查询

- index：对于前面的每一行，都通过查询索引来得到数据

- all：对于前面的每一行，都通过全表扫描来得到数据，未使用索引







https://www.cnblogs.com/chenshishuo/p/5030029.html