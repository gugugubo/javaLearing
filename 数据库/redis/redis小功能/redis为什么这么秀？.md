## 1. Redis 和 Memcached 有什么区别？

### 1.1 redis 支持复杂的数据结构

`Redis`不仅仅支持简单的k/v类型的数据，同时还提供`list，set，zset，hash`等数据结构的存储。memcache支持简单的数据类型，`String`。

### 1.2 redis 原生支持集群模式

在 `redis3.x` 版本中，原生便能支持 `cluster`（集群） 模式，而 `memcached` 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。

### 1.3 性能对比

由于 `redis` 只使用单核，而 `memcached` 可以使用多核，所以平均每一个核上 redis 在存储小数据时比 `memcached`  性能更高。而在 100k 以上的数据中，`memcached` 性能要高于 `redis`，虽然 `redis`  最近也在存储大数据的性能上进行优化，但是比起 `memcached`，还是稍有逊色。

![redis 和 memcached 的区别](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/61603179.jpg)

## 2. redis 的线程模型

**`redis` 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 `IO` 多路复用机制（[什么是IO多路复用？](https://www.zhihu.com/question/32163005)）同时监听多个 `socket`**，根据 `socket` 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

- 多个 `socket`
- `IO` 多路复用程序
- 文件事件分派器
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

以上四个部分的大概工作流程是这样的：多个 `socket` 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 `IO` 多路复用程序会监听多个 `socket`，会将 `socket` 产生的事件放入队列中排队，文件事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

具体流程如下：来看客户端与 `redis` 的一次通信过程：

![1586833542453](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200414110543-61940.png)

客户端 `socket01` 向 redis 的 `server socket` 请求建立连接，此时 `server socket` 会产生一个 `AE_READABLE` 事件，`IO` 多路复用程序监听到 `server socket` 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 `socket01`，并将该 `socket01` 的 `AE_READABLE` 事件与命令请求处理器关联。

假设此时客户端发送了一个 `set key value` 请求，此时 `redis` 中的 `socket01` 会产生 `AE_READABLE` 事件，`IO` 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 `socket01` 的 `AE_READABLE` 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 `socket01` 的 `key value` 并在自己内存中完成 `key value` 的设置。操作完成后，它会将 `socket01` 的 `AE_WRITABLE` 事件与命令回复处理器关联。

如果此时客户端准备好接收返回结果了，那么 `redis` 中的 `socket01` 会产生一个 `AE_WRITABLE` 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 `socket01` 输入本次操作的一个结果，比如 `ok`，之后解除 `socket01` 的 `AE_WRITABLE` 事件与命令回复处理器的关联。

这样便完成了一次通信。

## 3. 为啥 redis 单线程模型也能效率这么高？

1. 第一，纯内存访问，`Redis`将所有数据放在内存中，内存的响应时长大约为100纳秒，这是Redis达到每秒万级别访问的重要基础。
2. 第二，非阻塞`I/O`，`Redis`使用`epoll`作为`I/O`多路复用技术的实现，再加上`Redis`自身的事件处理模型将`epoll`中的连接、读写、关闭都转换为事件。
3. 第三，单线程避免了线程切换和竞态产生的消耗。既然采用单线程就能达到如此高的性能，那么也不失为一种不错的选择，因为单线程能带来几个好处：第一，单线程可以简化数据结构和算法的实现。如果对高级编程语言熟悉的读者应该了解并发数据结构实现不但困难而且开发测试比较麻烦。第二，单线程避免了线程切换和竞态产生的消耗，对于服务端开发来说，锁和线程切换通常是性能杀手。

但是单线程会有一个问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞，对于`Redis`这种高性能的服务来说是致命的，所以`Redis`是面向快速执行场景的数据库。

## 4. 参考

- https://www.javazhiyin.com/22943.html#m







