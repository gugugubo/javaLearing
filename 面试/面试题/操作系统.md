1. 进程间通讯的7种方式  https://blog.csdn.net/zhaohong_bo/article/details/89552188
   1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
   2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
   3. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
   4. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
   5. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
   6. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
   7. 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
   
2. 死锁产生的四个必要条件

   1. 互斥条件
   2. 不剥夺条件
   3. 循环等待
   4. 请求和保持
   5. ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410175208280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

3. 死锁如何处理

   1. 预防死锁

      1. 破坏互斥条件：将互斥的资源改为共享
      2. 破坏不可剥夺：1.主动放弃  2.操作系统协助
      3. 破坏请求和保持条件：可以一次性获取所有的资源
      4. 破坏循坏等待条件：可以顺序获取资源；

   2. 避免死锁：银行家算法
   
4. 进程调度算法（发生询问的时机：1.一个进程执行完了  2.有新的进程过来  3.cpu的时间片用完了）

   1. 旧的调度算法

      高响应比优先—HRRN

      最短剩余时间优先算法 SRTN

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405210919429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

   2. 新的调度算法

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405221830211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

5. 内存的扩充

   1. 旧的内存扩充

      1. ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200423175639916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)
      2. ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200423175532452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

   2. 虚拟存储技术

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200507181418228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200508164532762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

6. 连续分配管理的内存分配？

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200423183217819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

   动态分区分配：

   1. 系统要用怎样的数据结构记录内存的使用情况呢？分为空闲分区表和空闲分区链

   2. 当多个空闲分区都能满足要求时，应该选择哪个分区进行分配？分为空闲分区表和空闲分区链讨论；

      ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200423221937764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

   3. 如何进行分区的分配和回收操作？分为空闲分区表和空闲分区链讨论；

7. 非连续分配管理的内存分配？

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020050319145526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200503190414618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

8. 快表？

   1. ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200505111455765.png)

9. 磁盘调度算法

   1. ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527183847708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

​     



​      

