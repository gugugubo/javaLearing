



# spring

## 各种循环依赖的解决？

1. singletonsCurrentlyInCreation：解决**构造方法**循环依赖的问题

2. prototypesCurrentlyInCreation：解决**原型循环**依赖的问题

3. Map<String, Object> singletonObjects； Map<String, Object> earlySingletonObjects； Map<String, ObjectFactory<?>> singletonFactories：**解决setter和Filed注入**的循环依赖问题

   1. addSingleton  **其中一次**会在getSingleton(String beanName, ObjectFactory<?> singletonFactory) **两个参数**中被调用

   2. 二级缓存：添加：向里面添加数据只有一个地方，就是上面说的`getSingleton(beanName)` **一个参数**里从三级缓存里挪过来
       移除：`addSingleton、addSingletonFactory、removeSingleton`从代码中可以看出添加单例、添加单例工厂`ObjectFactory`的时候都会删除二级缓存里面对应的缓存值，是互斥的

   3. addSingletonFactory会在doCreateBean中被调用：**三级缓存中存的是对象的相关的ObjectFactory，如果被代理并且产生了循环依赖，那么就会提前进行aop的织入操作，doCreateBean里面的织入就不用再次进行了**

      1. 上面实现提前织入的代码为

         ```java
         // 下面是doCreateBean方法initializeBean里面的
         /** bean 初始化后置处理方法 */
         	public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
         		if (bean != null) {
         			Object cacheKey = getCacheKey(bean.getClass(), beanName);
         			if (this.earlyProxyReferences.remove(cacheKey) != bean) {
         				// 如果需要，为 bean 生成代理对象
         				return wrapIfNecessary(bean, beanName, cacheKey);
         			}
         		}
         		return bean;
         	}
         ```

         ```java
         // 下面是doCreateBean方法里面的
         addSingletonFactory(beanName, () -> {
         				// 获取早期 bean 的引用，如果 bean 中的方法被 AOP 切点所匹配到，此时 AOP 相关逻辑会介入
         				return getEarlyBeanReference(beanName, mbd, bean); // 看下面的函数
         			});
         
         	protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
         		Object exposedObject = bean;
         		if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
         			for (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {
         				exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);// 看AbstractAutoProxyCreator类，它实现了smartInstantiationAware接口
         			}
         		}
         		return exposedObject;
         	}
         // 其中的AbstractAutoProxyCreator.getEarlyBeanReference方法
         @Override
         public Object getEarlyBeanReference(Object bean, String beanName) {
            Object cacheKey = getCacheKey(bean.getClass(), beanName);
            this.earlyProxyReferences.put(cacheKey, bean);
            return wrapIfNecessary(bean, beanName, cacheKey);
         }
         ```



## 为什么需要三级缓存？

1. 为什么需要三级缓存？3级缓存在这里有什么目的呢？
   1. 3级缓存里面保存的是对象工厂，这个对象工厂内部保留着最原生的对象引用，ObjectFactory的实现类，getObject()方法，它需要考虑一个问题。它到底要返回原生的，还是增强后的。getObject会判断当前这个早期实例 是否需要被增强，如果是，那么提前完成动态代理增强，返回代理对象。否则，返回原生对象。

## springioc的步骤？

1. getBean->doGetBean
   1. 尝试获取缓存
   2. 解决原型依赖
   3. 合并beanDefinition
   4. 解决depend-on依赖
2. getSingleton
   1. beforeSingletonCreation
   2. afterSingletonCreation
   3. addSingleton
3. createBean
   1. 处理 lookup-method 和 replace-method 配置
   2. 在 bean 初始化前应用后置处理resolveBeforeInstantiation（注意applyBeanPostProcessorsBeforeInstantiation和applyBeanPostProcessorsAfterInitialization的区别，前一个是InstantiationAwareBeanPostProcessor接口的，后一个是BeanPostProcessor接口的）
4. doGetBean
   1. createBeanInstance
   2. 添加到三级缓存
   3. populateBean
   4. initializeBean
      1. 若 bean 实现了 BeanNameAware、BeanFactoryAware、BeanClassLoaderAware 等接口，则向 bean 中注入相关对象
      2. 执行 bean 初始化前置操作
      3. 调用初始化方法invokeInitMethods
      4. 执行 bean 初始化后置操作

## Spring生命周期详细描述?

[5.5 Spring 中的 bean 生命周期?](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring常见问题总结?id=_55-spring-中的-bean-生命周期)

这部分网上有很多文章都讲到了，下面的内容整理自：https://yemengying.com/2016/07/14/spring-bean-life-cycle/ ，除了这篇文章，再推荐一篇很不错的文章 ：https://www.cnblogs.com/zrtqsk/p/3735273.html 。

- Bean 容器找到配置文件中 Spring Bean 的定义。
- Bean 容器利用 Java Reflection API 创建一个Bean的实例。
- 如果涉及到一些属性值 利用 `set()`方法设置一些属性值。
- 如果 Bean 实现了 `BeanNameAware` 接口，调用 `setBeanName()`方法，传入Bean的名字。
- 如果 Bean 实现了 `BeanClassLoaderAware` 接口，调用 `setBeanClassLoader()`方法，传入 `ClassLoader`对象的实例。
- 与上面的类似，如果实现了其他 `*.Aware`接口，就调用相应的方法。
- 如果有和加载这个 Bean 的 Spring 容器相关的 `BeanPostProcessor` 对象，执行`postProcessBeforeInitialization()` 方法
- 如果Bean实现了`InitializingBean`接口，执行`afterPropertiesSet()`方法。
- 如果 Bean 在配置文件中的定义包含  init-method 属性，执行指定的方法。
- 如果有和加载这个 Bean的 Spring 容器相关的 `BeanPostProcessor` 对象，执行`postProcessAfterInitialization()` 方法
- 当要销毁 Bean 的时候，如果 Bean 实现了 `DisposableBean` 接口，执行 `destroy()` 方法。
- 当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。

图示：

![Spring Bean 生命周期](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/48376272.jpg)

与之比较类似的中文版本:

![Spring Bean 生命周期](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg)



## 如何保证Bean的线程安全?

https://blog.csdn.net/weixin_43727372/article/details/100324678

1. threadlocal 
2. 使用多例
3. 设计时避免有状态

## Spring中的AOP是如何实现的，jdk和CGLIB方法的区别?

1. AbstractAdvisorAutoProxyCreator实现了BeanFactoryAware接口，ioc容器为它做了啥？
2. AbstractAdvisorAutoProxyCreator作为InstantiationAwareBeanPostProcessor接口做了啥？
   1. 解析 @Aspect 注解，并构建通知器aspectJAdvisorsBuilder.buildAspectJAdvisors
      1. beanType 判断当前 bean 是否是一个的 Aspect 注解类
         1. getAdvisorMethods 用于返回不包含 @Pointcut 注解的方法，为每个方法分别调用 getAdvisor 方法
   2. createAopProxy
      1. 获取适合当前方法的拦截器getInterceptorsAndDynamicInterceptionAdvice
         1. 对于 PointcutAdvisor 类型的通知器，这里要调用通知器所持有的切点（Pointcut）对类和方法进行匹配，匹配成功说明应向当前方法织入通知逻辑
      2. invocation.proceed()执行拦截器链



## spring怎么实现事务的？

https://developer.ibm.com/zh/articles/j-master-spring-transactional-use/

1. 步骤：

   1. > 1. 编程式事务，在代码中硬编码。(不推荐使用)
      > 2. 声明式事务，在配置文件中配置（推荐使用）
      >
      > **声明式事务又分为两种：**
      >
      > 1. 基于XML的声明式事务
      > 2. 基于注解的声明式事务

      

2. 原理：

   1. AutoProxyRegistrar的InfrastructureAdvisorAutoProxyCreator 接口做了啥？Infrastructure（基础设施）
   2. ProxyTransactionManagementConfiguration 做了啥？
      1. transactionAttributeSource：解析事务注解，就是获取注解中各种属性的值
      2. transactionInterceptor：保存了事务属性信息transactionAttributeSource，事务管理器 txManager
         1. 看看拦截器的invoke方法
            1. 先获取事务相关的属性  transactionAttributeSource
            2. 再获取PlatformTransactionManager，如果事先没有添加指定任何transactionmanger （在@Transactional注解中可以指定）；最终会从容器中按照类型获取一个PlatformTransactionManager； 
            3. 执行目标方法；；如果异常，获取到事务管理器，利用事务管理回滚操作；；如果正常，利用事务管理器，提交事务



## Spring事务失效和解决方案？

1. 正确的设置 @Transactional 的 propagation 属性
   1. TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
   2. TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
   3. TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。
2. 正确的设置 @Transactional 的 rollbackFor 属性
3. @Transactional 只能应用到 public 方法才有效
4. 避免 Spring 的 AOP 的自调用问题



## 说说IOC和AOP？

自己的总结：

1. IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个  Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC  的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。
2. aop：AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度。Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib 

#### [IoC](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring常见问题总结?id=ioc)

IoC（Inverse of Control:控制反转）是一种**设计思想**，就是 **将原本在程序中手动创建对象的控制权，交由Spring框架来管理。**  IoC 在其他语言中也有应用，并非 Spring 特有。 **IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。**

将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  **IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。** 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个  Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC  的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。

Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。

推荐阅读：https://www.zhihu.com/question/23277575/answer/169698662

**Spring IoC的初始化过程：** 

![Spring IoC的初始化过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringIOC初始化过程.png)

IoC源码阅读

- https://javadoop.com/post/spring-ioc

#### [AOP](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring常见问题总结?id=aop)

AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，**却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来**，便于**减少系统的重复代码**，**降低模块间的耦合度**，并**有利于未来的可拓展性和可维护性**。

**Spring AOP就是基于动态代理的**，如果要代理的对象，实现了某个接口，那么Spring AOP会使用**JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用**Cglib** ，这时候Spring AOP会使用 **Cglib** 生成一个被代理对象的子类来作为代理，如下图所示：

![SpringAOPProcess](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg)

当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。

使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。