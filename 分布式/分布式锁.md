# 一 使用分布式锁要满足的几个条件：

1. 系统是一个分布式系统（关键是分布式，单机的可以使用ReentrantLock或者synchronized代码块来实现）
2. 共享资源（各个系统访问同一个资源，资源的载体可能是传统关系型数据库或者NoSQL）
3. 同步访问（即有很多个进程同事访问同一个共享资源。没有同步访问，谁管你资源竞争不竞争）

# 二 应用的场景例子

　　管理后台的部署架构（多台tomcat服务器+redis【多台tomcat服务器访问一台redis】+mysql【多台tomcat服务器访问一台服务器上的mysql】）就满足使用分布式锁的条件。多台服务器要访问redis全局缓存的资源，如果不使用分布式锁就会出现问题。 看如下伪代码：

```java
long N=0L;
//N从redis获取值
if(N<5){
N++；
//N写回redis
}
```

上面的代码主要实现的功能：

　　从redis获取值N，对数值N进行边界检查，自加1，然后N写回redis中。 这种应用场景很常见，像秒杀，全局递增ID、IP访问限制等。以IP访问限制来说，恶意攻击者可能发起无限次访问，并发量比较大，分布式环境下对N的边界检查就不可靠，**因为从redis读的N可能已经是脏数据。传统的加锁的做法（如java的synchronized和Lock）也没用，因为这是分布式环境**，这个同步问题的救火队员也束手无策。在这危急存亡之秋，分布式锁终于有用武之地了。

分布式锁可以基于很多种方式实现，不管哪种方式，他的**基本原理**是不变的：**用一个状态值表示锁，对锁的占用和释放通过状态值来标识。**

- Memcached：利用 Memcached 的 `add` 命令。此命令是原子性操作，只有在 `key` 不存在的情况下，才能 `add` 成功，也就意味着线程得到了锁。
- Redis：和 Memcached 的方式类似，利用 Redis 的 `setnx` 命令。此命令同样是原子性操作，只有在 `key` 不存在的情况下，才能 `set` 成功。
-  **Zookeeper**：利用 Zookeeper 的顺序临时节点，来实现分布式锁和等待队列。Zookeeper 设计的初衷，就是为了实现分布式锁服务的。
- Chubby：Google 公司实现的粗粒度分布式锁服务，底层利用了 Paxos 一致性算法。



# 三 使用redis实现分布式锁

https://www.cnblogs.com/0201zcr/p/5942748.html   这个也好难

https://www.jianshu.com/p/a1ebab8ce78a  这篇文章的后部分没有看懂，就是如何利用redis设计一个合理的锁！

# 四 使用zookeeper实现分布式锁