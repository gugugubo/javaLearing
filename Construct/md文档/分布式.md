## 1、什么是分布式？

​	分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。

《分布式系统原理与范型》定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”分布式系统（distributed system）是建立在网络之上的软件系统。

**更多分布式，SOA 分布式详细的概念参考：**https://blog.csdn.net/binggetong/article/details/79126359

## 2. RPC是什么？RPC原理是什么？

#### 2.1RPC是什么？

​	RPC【Remote Procedure Call】是指远程过程调用，是一种**进程间通信方式**，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。

​	一般来说进程间的调用可以通过两种方法，一种是http，spring cloud就是通过http进行通信的。但是使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题，实现 RPC 的可以传输协议可以直接建立在 TCP 之上，也可以建立在 HTTP 协议之上。大部分 RPC 框架都是使用的 TCP 连接。

​	更多详情可以参考：https://snailclimb.gitee.io/javaguide/#/docs/system-design/data-communication/why-use-rpc

#### 2.2 RPC原理是什么？

![RPC原理图](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200304161308-327154.jpeg)

RPC两个核心模块：**通讯，序列化**。在网络间进行传输，必须对参数实现序列化！

1. 服务消费方（client）调用以本地调用方式调用服务；
2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
3. client stub找到服务地址，并将消息发送到服务端；
4. server stub收到消息后进行解码；
5. server stub根据解码结果调用本地的服务；
6. 本地服务执行并将结果返回给server stub；
7. server stub将返回结果打包成消息并发送至消费方；
8. client stub接收到消息，并进行解码；
9. 服务消费方得到最终结果。

## 3.分布式的CAP？BASE？

#### 3.1 CAP定理

###### 什么是cap？

**Consistency（一致性）：**

在分布式系统中的所有数据备份，在同一时刻是否同样的值。（写操作之后的读操作，必须返回该值。更新操作执行成功后所有的用户都应该读到最新的值，要求所有的备份数据保持一致）

**Availability（可用性）：**

在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（要求数据需要备份）

**Partition tolerance（分区容错）：**

大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。

​	CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。只能 CP、AP。在单节点系统中不用考虑这些问题。

**CAP的更详细解释请参考：**https://blog.csdn.net/yeyazhishang/article/details/80758354

#### 3.2 BASE（理论）

- Basically Available（基本可用）、
- Soft state（软状态）
- Eventually consistent（最终一致性）

三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。接下来我们着重对BASE中的三要素进行详细讲解。

 

## 4. Dubbo

#### 4.1dubbo的简介

​	dubbo就是rpc思想的其中一种实现啦！Apache Dubbo (incubating) 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。

dubbo的优势：

1. **负载均衡**——同一个服务部署在不同的机器时该调用那一台机器上的服务。
2. **服务调用链路生成**——随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。
3. **服务访问压力以及时长统计、资源调度和治理**——基于访问压力实时管理集群容量，提高集群利用率。
4. **服务降级**——某个服务挂掉之后调用备用服务。

#### 4.2 dubbo的具体实现过程

![1576342692879](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200304161256-299114.png)



**上述节点简单说明**：

- 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。
- 服务消费者（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
- 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者
- 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心

调用关系说明

- 服务容器负责启动，加载，运行服务提供者。
-  服务提供者在启动时，向注册中心注册自己提供的服务。
- 服务消费者在启动时，向注册中心订阅自己所需的服务。
-  注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
-  服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
- 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

## 5. Dubbo 的负载均衡策略

#### 5.1什么是负载均衡

​	比如我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。

#### 5.2负载均衡的种类

##### 5.2.1  Random LoadBalance(默认，基于权重的随机负载均衡机制

- 随机，按权重设置随机概率。
- 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。

![基于权重的随机负载均衡机制](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200304161311-448281.jpeg)

##### 5.2.2 RoundRobin LoadBalance(不推荐，基于权重的轮询负载均衡机制

- 轮循，按公约后的权重设置轮循比率。

- 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。

  ![基于权重的轮询负载均衡机制](https://gitee.com/gu_chun_bo/picture/raw/master/image/20200304161310-438623.jpeg)

##### 5.2.3 LeastActive LoadBalance

- 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。
- 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。

##### 5.2.4  ConsistentHash LoadBalance

- 一致性 Hash，相同参数的请求总是发到同一提供者。(如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略。)
- 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。
- 算法参见：http://en.wikipedia.org/wiki/Consistent_hashing

## 6.Dubbo项目实战

参考文章：https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484706&idx=1&sn=d413fc17023482f67ca17cb6756b9ff8&chksm=fd985343caefda555969568fdf4734536e0a1745f9de337d434a7dbd04e893bd2d75f3641aab&token=1902169190&lang=zh_CN#rd